# 0. 概述
## 本章主要内容
- 什么是算法
- 好算法的标准
- 算法复杂度计算方法
- 递归算法复杂度计算
- 常见算法复杂度

## 1. 什么是算法
算法是指对特定问题求解步骤的一种描述，算法只是对问题求解方法的一种描述,它不依赖于任何一种语言,既可以用自然语言、程序设计语言(C、C++、Java、Python 等)描述,也可以用流程图、框图来表示。一般为了更清楚地说明算法的本质,我们去除了计算机语言的语法规则和细节,采用“伪代码”来描述算法。
### 1.1 算法的特征
1. 有穷性：算法是由若干条指令组成的有穷序列,总是在执行若干次后结束,不可能永不停止。
2. 确定性：每条语句有确定的含义,无歧义。
3. 可行性：算法在当前环境条件下可以通过有限次运算实现。
4. 输入输出：有零个或多个输入,一个或多个输出。
## 2. 好算法的标准

1. 正确性：正确性是指算法能够满足具体问题的需求,程序运行正常,无语法错误,
   能够通过典型的软件测试,达到预期的需求。
2. 易读性：法遵循标识符命名规则,简洁易懂,注释语句恰当适量,方便自己和他
   人阅读,便于后期调试和修改。
3. 健壮性：算法对非法数据及操作有较好的反应和处理。例如,在学生信息管理系统
   中登记学生年龄时,若将 21 岁误输入为 210 岁,系统应该提示出错。
4. 高效性：高效性是指算法运行效率高,即算法运行所消耗的时间短。
5. 低存储性：低存储性是指算法所需要的存储空间低。

## 3. 算法复杂度计算方法

```c++
sum=0;	            //运行 1 次
total=0;	        //运行 1 次
for(i=1; i<=n; i++)	//运行 n+1 次
{
sum=sum+i;	        //运行 n 次
for(j=1; j<=n; j++)	//运行 n * (n+1)次
total=total+i * j;  //运行 n * n 次
}
```

把算法的所有语句的运行次数加起来:$1+1+n+1+n+n×(n+1)+n×n$,可以用一个函数
$T(n)$表达:

$$T(n)=2n^2 +3n+3$$

当n足够大时,例如$n=10^5$ 时,$T(n)=2×10^{10} +3×10^5 +3$,我们可以看到算法运行时间主要取决于第一项,后面的甚至可以忽略不计。用极限表示为:

$$limit \dfrac{T(n)}{f(n)}=C$$

其中C为不等于0的常数。

## 4. 递归算法复杂度

例1：如果算法的执行时间不随着问题规模n的增加而增长，它的基本语句执行的次数是固定的，总的时间由一个常数来限界。此类算法的时间复杂度是O(1)。
例2：当有若干个循环语句时，时间复杂度是由嵌套层数最多的循环语句中的基本语句的执行次数决定。如下

```c++
void fun(int n){
    int x=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            for(int k=1;k<=j;k++){
                x++;             //基本语句
            }
        }
    }
}
```

解：该算法的基本语句是x++;所以时间复杂度为$O(n^3)$。

## 5. 常见的算法复杂度

1. 常数阶
常数阶算法运行的次数是一个常数,如 5、20、100。常数阶算法时间复杂度通常用 О(1)表示。
2. 多项式阶
很多算法时间复杂度是多项式,通常用 $O(n)$、$O(n^2) $、$O(n^3)$等表示。
3. 指数阶
指数阶时间复杂度运行效率极差,程序员往往像躲“恶魔”一样避开它。常见的有 $O(2^n)$、$O(n!)$、$O(n^n)$等。
4. 对数阶
对数阶时间复杂度运行效率较高,常见的有 $О(logn)$、$О(nlogn)$等。

从图中可以看出,指数阶增量随着 x 的增加而急剧增加,而对数阶增加缓慢。它们之间的关系为:

$$О(1)< О(logn)< О(n)< О(nlogn) < О(n^2)< О(n^3)< О(2^n) < О(n!)< О(n^n)$$

## 6. 刷题网站

 https://www.luogu.org